% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dt_ddply.R
\name{dt_ddply}
\alias{dt_ddply}
\alias{dt_ldply}
\alias{dt_dlply}
\title{Split \code{data.table}, apply function, and return results in a \code{data.table}.}
\usage{
dt_ddply(
  .data,
  .variables,
  .f = NULL,
  ...,
  .progress = "none",
  .inform = FALSE,
  .drop = TRUE,
  .parallel = FALSE,
  .paropts = NULL
)

dt_ldply(
  .data,
  .fun = NULL,
  ...,
  .progress = "none",
  .inform = FALSE,
  .parallel = FALSE,
  .paropts = NULL,
  .id = NA
)

dt_dlply(
  .data,
  .variables,
  .fun = NULL,
  ...,
  .progress = "none",
  .inform = FALSE,
  .drop = TRUE,
  .parallel = FALSE,
  .paropts = NULL
)
}
\arguments{
\item{.data}{data frame to be processed}

\item{.variables}{variables to split data frame by, as \code{\link[plyr]{as.quoted}}
variables, a formula or character vector}

\item{.f}{A function, formula, or vector (not necessarily atomic).

If a \strong{function}, it is used as is.

If a \strong{formula}, e.g. \code{~ .x + 2}, it is converted to a function. There
are three ways to refer to the arguments:
\itemize{
\item For a single argument function, use \code{.}
\item For a two argument function, use \code{.x} and \code{.y}
\item For more arguments, use \code{..1}, \code{..2}, \code{..3} etc
}

This syntax allows you to create very compact anonymous functions.

If \strong{character vector}, \strong{numeric vector}, or \strong{list}, it is
converted to an extractor function. Character vectors index by
name and numeric vectors index by position; use a list to index
by position and name at different levels. If a component is not
present, the value of \code{.default} will be returned.}

\item{...}{other arguments passed on to \code{.fun}}

\item{.progress}{name of the progress bar to use, see
\code{\link[plyr]{create_progress_bar}}}

\item{.inform}{produce informative error messages?  This is turned off
by default because it substantially slows processing speed, but is very
useful for debugging}

\item{.drop}{should combinations of variables that do not appear in the
input data be preserved (FALSE) or dropped (TRUE, default)}

\item{.parallel}{if \code{TRUE}, apply function in parallel, using parallel
backend provided by foreach}

\item{.paropts}{a list of additional options passed into
the \code{\link[foreach]{foreach}} function when parallel computation
is enabled.  This is important if (for example) your code relies on
external data or packages: use the \code{.export} and \code{.packages}
arguments to supply them so that all cluster nodes have the correct
environment set up for computing.}

\item{.fun}{function to apply to each piece}

\item{.id}{Either a string or \code{NULL}. If a string, the output will contain
a variable with that name, storing either the name (if \code{.x} is named) or
the index (if \code{.x} is unnamed) of the input. If \code{NULL}, the default, no
variable will be created.

Only applies to \verb{_dfr} variant.}
}
\description{
For each subset of a \code{data.table}, apply function then combine results into a \code{data.table}.
}
\examples{
dt <- data.table(x = 1:10, y = 1:5)
dt_ddply(dt, .(y), ~.[which.max(x)])
dt_ddply(dt, .(y), ~ top_n(., 1, x))
}
