% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/main_dt_ddply.R
\name{dt_ddply}
\alias{dt_ddply}
\alias{dt_ldply}
\alias{dt_dlply}
\title{Split \code{data.table}, apply function, and return results in a \code{data.table}.}
\usage{
dt_ddply(
  .data,
  .variables,
  .f = NULL,
  ...,
  .progress = "none",
  .drop = TRUE,
  .parallel = FALSE
)

dt_ldply(
  .data,
  .f = NULL,
  ...,
  .progress = "none",
  .parallel = FALSE,
  .id = NA
)

dt_dlply(
  .data,
  .variables,
  .f = NULL,
  ...,
  .progress = "none",
  .drop = TRUE,
  .parallel = FALSE
)
}
\arguments{
\item{.data}{data frame to be processed}

\item{.variables}{variables to split data frame by, as \code{\link[plyr]{as.quoted}}
variables, a formula or character vector}

\item{.f}{A function, specified in one of the following ways:
\itemize{
\item A named function, e.g. \code{mean}.
\item An anonymous function, e.g. \verb{\\(x) x + 1} or \code{function(x) x + 1}.
\item A formula, e.g. \code{~ .x + 1}. You must use \code{.x} to refer to the first
argument. Only recommended if you require backward compatibility with
older versions of R.
\item A string, integer, or list, e.g. \code{"idx"}, \code{1}, or \code{list("idx", 1)} which
are shorthand for \verb{\\(x) pluck(x, "idx")}, \verb{\\(x) pluck(x, 1)}, and
\verb{\\(x) pluck(x, "idx", 1)} respectively. Optionally supply \code{.default} to
set a default value if the indexed element is \code{NULL} or does not exist.
}}

\item{...}{other arguments passed on to \code{.fun}}

\item{.progress}{name of the progress bar to use, see
\code{\link[plyr]{create_progress_bar}}}

\item{.drop}{should combinations of variables that do not appear in the
input data be preserved (FALSE) or dropped (TRUE, default)}

\item{.parallel}{if \code{TRUE}, apply function in parallel, using parallel
backend provided by foreach}
}
\description{
For each subset of a \code{data.table}, apply function then combine results into a \code{data.table}.
}
\examples{
dt <- data.table(x = 1:10, y = 1:5)
dt_dlply(dt, .(y), ~.[which.max(x)])
dt_ddply(dt, .(y), ~ top_n(., 1, x))
}
